[{"content":"1. 前言 掌握一门编程语言的关键之一就是多动手写代码。 当我不知道该写什么代码时，通常会选择造轮子。 造轮子的过程中不仅能让我更加熟悉语言的特性，还能让我深入思考这些轮子的底层实现原理。 同时，造好的轮子也可以用于以后的项目中，从而提高开发效率。\nC++ 是一门非常适合造轮子的语言，搭配上 CMake 这个构建工具，可以轻松构建出一个专属于自己的轮子库。 这样在以后的项目中，只需要引入这个库，就可以使用自己造的轮子了。\n例如，当我曾经实现了一个线程池，未来如果要使用它， 只需要 include 我的 wheel 库：\n#include \u0026lt;wheel/thread_pool.hpp\u0026gt; int main() { wheel::ThreadPool thread_pool(4); ... } 本文将会用一个简单的例子来介绍如何使用 C++ 和 CMake 来构建一个专属于自己的轮子库。\n2. 例子介绍 本文的目标是实现一个加法器，输入两个整数，加法器会输出它们的和。 这个加法器用到了wheel库中的math.hpp文件里面的add函数。\n3. 构建轮子库 首先来看一下最终的 wheel 库目录结构：\nwheel ├── CMakeLists.txt ├── include │ └── wheel │ └── math.hpp └── src └── math.cpp 约定include/wheel内存的头文件是对外公开的接口，src内存源文件（也可以存私有头文件），test内存的测试文件。\n接下来我们分别来看一下这几个文件的内容。\ninclude/wheel/math.hpp定义要暴露的接口：\n#pragma once namespace wheel { int add(int a, int b); } // namespace wheel 信息\n任何 C++ 项目都要有单独的命名空间，以避免与其他库命名冲突。\nsrc/math.cpp实现接口的功能:\n#include \u0026lt;wheel/math.hpp\u0026gt; namespace wheel { int add(int a, int b) { return a + b; } } // namespace wheel CMakelists.txt文件内容如下：\ncmake_minimum_required(VERSION 3.16) option(BUILD_WHEEL_TEST \u0026#34;build wheel test\u0026#34; OFF) set(TARGET wheel) set(CMAKE_CXX_STANDARD 23) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_CXX_EXTENSIONS OFF) set(CMAKE_EXPORT_COMPILE_COMMANDS 1) project( ${TARGET} VERSION 0.1.0 DESCRIPTION \u0026#34;wheel\u0026#34; HOMEPAGE_URL \u0026#34;https://github.com/m1dsolo/wheel\u0026#34; LANGUAGES C CXX ) file(GLOB_RECURSE SRC CONFIGURE_DEPENDS \u0026#34;src/*.cpp\u0026#34;) add_library(${TARGET} OBJECT ${SRC}) target_include_directories(${TARGET} PUBLIC include) if (BUILD_WHEEL_TEST) add_subdirectory(test) endif() 如果有看不懂的选项，可以让 GPT 帮你讲解～\n接下来使用以下命令来进行构建和编译：\ncmake -B build -G Ninja cmake --build build -j8 4. 使用轮子库 创建一个新项目adder，其目录结构如下：\nadder ├── CMakeLists.txt ├── src │ └── main.cpp └── third_party └── wheel src/main.cpp内容如下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;wheel/math.hpp\u0026gt; int main() { int res = wheel::add(1, 2); std::cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; std::endl; return 0; } CMakeLists.txt内容如下：\ncmake_minimum_required(VERSION 3.16) set(TARGET adder) set(CMAKE_CXX_STANDARD 23) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_CXX_EXTENSIONS OFF) set(CMAKE_EXPORT_COMPILE_COMMANDS 1) project( ${TARGET} VERSION 0.1.0 DESCRIPTION \u0026#34;adder\u0026#34; HOMEPAGE_URL \u0026#34;https://github.com/m1dsolo/adder\u0026#34; LANGUAGES C CXX ) set(WHEEL_ROOT ${PROJECT_SOURCE_DIR}/third_party/wheel) add_subdirectory(${WHEEL_ROOT}) file(GLOB_RECURSE SRC CONFIGURE_DEPENDS \u0026#34;src/*.cpp\u0026#34;) add_executable(${TARGET} ${SRC}) target_include_directories(${TARGET} PRIVATE include PRIVATE ${WHEEL_ROOT}/include ) target_link_libraries(${TARGET} PRIVATE wheel ) 也就是编译时同时需要编译并链接wheel库。\n接下来构建并编译adder程序：\ncmake -B build -G Ninja cmake --build build -j8 编译后我们就可以成功运行adder了：\n./build/adder 可以看到终端上输出了我们的预期结果。\n5. 测试轮子库（可选） 轮子库本质上就是一个 C++项目，推荐在写好轮子后，写一些测试用例来验证轮子的正确性。 这里我们选择使用 GoogleTest 来进行测试。\n在wheel内添加：\nwheel ├── test │ ├── CMakeLists.txt │ └── math.cpp └── third_party 安装 GoogleTest 到third_party/googletest：\ngit submodule add --depth=1 https://github.com/google/googletest.git third_party/googletest 在test/CMakeLists.txt中添加：\nset(TARGET test) set(GTEST_ROOT ${PROJECT_SOURCE_DIR}/third_party/googletest) add_subdirectory(${GTEST_ROOT} ${CMAKE_BINARY_DIR}/googletest) enable_testing() file(GLOB_RECURSE SRC \u0026#34;*.cpp\u0026#34;) add_executable(${TARGET} ${SRC}) target_include_directories(${TARGET} PRIVATE ${GTEST_ROOT}/include PRIVATE ${PROJECT_SOURCE_DIR}/include ) target_link_libraries(${TARGET} PRIVATE GTest::gtest_main PRIVATE wheel ) add_test(NAME ${TARGET} COMMAND ${TARGET}) 在test/math.cpp添加对 math 的测试用例：\n#include \u0026lt;wheel/math.hpp\u0026gt; #include \u0026lt;gtest/gtest.h\u0026gt; namespace wheel { TEST(MathTest, AddFunction) { EXPECT_EQ(wheel::add(1, 1), 2); EXPECT_EQ(wheel::add(-1, 1), 0); EXPECT_EQ(wheel::add(-1, -1), -2); EXPECT_EQ(wheel::add(0, 0), 0); } } // namespace wheel 由于之前我们已经配置了BUILD_WHEEL_TEST这个 option ，所以只需要在构建项目的时候指定这个参数：\ncmake -B build -G Ninja -DBUILD_WHEEL_TEST=ON cmake --build build -j8 编译成功后运行测试：\n./build/test/test 6. 结语 在完成轮子库的构建后，建议撰写一些笔记或博客，记录下整个过程和思考。 这不仅有助于巩固所学知识，还能在未来需要时快速回顾和使用这些轮子库。 通过不断地实践和总结，能够更深入地理解编程语言和工具的特性，从而提升开发效率和代码质量。\n你可以参考我分享的 轮子库 ， 代码仅供学习参考，不建议直接用于生产环境。\n以后有时间，我会分享一些曾经造过的轮子的实现原理，敬请期待！\n","permalink":"https://m1dsolo.github.io/posts/cpp-wheel/","summary":"\u003ch2 id=\"1-前言\"\u003e1. 前言\u003c/h2\u003e\n\u003cp\u003e掌握一门编程语言的关键之一就是多动手写代码。\n当我不知道该写什么代码时，通常会选择造轮子。\n造轮子的过程中不仅能让我更加熟悉语言的特性，还能让我深入思考这些轮子的底层实现原理。\n同时，造好的轮子也可以用于以后的项目中，从而提高开发效率。\u003c/p\u003e\n\u003cp\u003eC++ 是一门非常适合造轮子的语言，搭配上 CMake 这个构建工具，可以轻松构建出一个专属于自己的轮子库。\n这样在以后的项目中，只需要引入这个库，就可以使用自己造的轮子了。\u003c/p\u003e\n\u003cp\u003e例如，当我曾经实现了一个线程池，未来如果要使用它，\n只需要 \u003ccode\u003einclude\u003c/code\u003e 我的 \u003ccode\u003ewheel\u003c/code\u003e 库：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;wheel/thread_pool.hpp\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ewheel\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eThreadPool\u003c/span\u003e \u003cspan class=\"n\"\u003ethread_pool\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e本文将会用一个简单的例子来介绍如何使用 C++ 和 CMake 来构建一个专属于自己的轮子库。\u003c/p\u003e\n\u003ch2 id=\"2-例子介绍\"\u003e2. 例子介绍\u003c/h2\u003e\n\u003cp\u003e本文的目标是实现一个加法器，输入两个整数，加法器会输出它们的和。\n这个加法器用到了\u003ccode\u003ewheel\u003c/code\u003e库中的\u003ccode\u003emath.hpp\u003c/code\u003e文件里面的\u003ccode\u003eadd\u003c/code\u003e函数。\u003c/p\u003e\n\u003ch2 id=\"3-构建轮子库\"\u003e3. 构建轮子库\u003c/h2\u003e\n\u003cp\u003e首先来看一下最终的 \u003ccode\u003ewheel\u003c/code\u003e 库目录结构：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewheel\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── CMakeLists.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e├── include\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│   └── wheel\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e│       └── math.hpp\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e└── src\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    └── math.cpp\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e约定\u003ccode\u003einclude/wheel\u003c/code\u003e内存的头文件是对外公开的接口，\u003ccode\u003esrc\u003c/code\u003e内存源文件（也可以存私有头文件），\u003ccode\u003etest\u003c/code\u003e内存的测试文件。\u003c/p\u003e\n\u003cp\u003e接下来我们分别来看一下这几个文件的内容。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einclude/wheel/math.hpp\u003c/code\u003e定义要暴露的接口：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#pragma once\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003ewheel\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// namespace wheel\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cstyle type=\"text/css\"\u003e\n     \n    .notice {\n        --title-color: #fff;\n        --title-background-color: #6be;\n        --content-color: #444;\n        --content-background-color: #e7f2fa;\n    }\n\n    .notice.info {\n        --title-background-color: #fb7;\n        --content-background-color: #fec;\n    }\n\n    .notice.tip {\n        --title-background-color: #5a5;\n        --content-background-color: #efe;\n    }\n\n    .notice.warning {\n        --title-background-color: #c33;\n        --content-background-color: #fee;\n    }\n\n     \n    @media (prefers-color-scheme:dark) {\n        .notice {\n            --title-color: #fff;\n            --title-background-color: #069;\n            --content-color: #ddd;\n            --content-background-color: #023;\n        }\n\n        .notice.info {\n            --title-background-color: #a50;\n            --content-background-color: #420;\n        }\n\n        .notice.tip {\n            --title-background-color: #363;\n            --content-background-color: #121;\n        }\n\n        .notice.warning {\n            --title-background-color: #800;\n            --content-background-color: #400;\n        }\n    }\n\n    body.dark .notice {\n        --title-color: #fff;\n        --title-background-color: #069;\n        --content-color: #ddd;\n        --content-background-color: #023;\n    }\n\n    body.dark .notice.info {\n        --title-background-color: #a50;\n        --content-background-color: #420;\n    }\n\n    body.dark .notice.tip {\n        --title-background-color: #363;\n        --content-background-color: #121;\n    }\n\n    body.dark .notice.warning {\n        --title-background-color: #800;\n        --content-background-color: #400;\n    }\n\n     \n    .notice {\n        padding: 18px;\n        line-height: 24px;\n        margin-bottom: 24px;\n        border-radius: 4px;\n        color: var(--content-color);\n        background: var(--content-background-color);\n    }\n\n    .notice p:last-child {\n        margin-bottom: 0\n    }\n\n     \n    .notice-title {\n        margin: -18px -18px 12px;\n        padding: 4px 18px;\n        border-radius: 4px 4px 0 0;\n        font-weight: 700;\n        color: var(--title-color);\n        background: var(--title-background-color);\n    }\n\n     \n    .icon-notice {\n        display: inline-flex;\n        align-self: center;\n        margin-right: 8px;\n    }\n\n    .icon-notice img,\n    .icon-notice svg {\n        height: 1em;\n        width: 1em;\n        fill: currentColor;\n    }\n\n    .icon-notice img,\n    .icon-notice.baseline svg {\n        top: .125em;\n        position: relative;\n    }\n\u003c/style\u003e\u003cdiv class=\"notice info\" \u003e\n    \u003cp class=\"notice-title\"\u003e\n        \u003cspan class=\"icon-notice baseline\"\u003e\n            \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"92 59.5 300 300\"\u003e\n  \u003cpath d=\"M292 303.25V272c0-3.516-2.734-6.25-6.25-6.25H267v-100c0-3.516-2.734-6.25-6.25-6.25h-62.5c-3.516 0-6.25 2.734-6.25 6.25V197c0 3.516 2.734 6.25 6.25 6.25H217v62.5h-18.75c-3.516 0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h87.5c3.516 0 6.25-2.734 6.25-6.25Zm-25-175V97c0-3.516-2.734-6.25-6.25-6.25h-37.5c-3.516 0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h37.5c3.516 0 6.25-2.734 6.25-6.25Zm125 81.25c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z\"/\u003e\n\u003c/svg\u003e\n\n        \u003c/span\u003e信息\u003c/p\u003e","title":"在 C++ 中使用 CMake 构建专属于自己的轮子库"},{"content":"1. 前言 dwm 是 X11 下的平铺式窗口管理器，它是用 C 语言编写的，非常轻量级，全部代码也才不到 2k 行。 它提供了一些基本的窗口管理功能，对于额外的功能，可以通过修改源码来实现。 目前 suckless 官网 上提供了非常多的补丁，可以用来扩展 dwm 的功能。\n其中一个很重要的补丁就是 swallow ， 它可以让 dwm 在启动一个新的应用程序时，将其嵌入到一个已有的窗口中，而不是启动一个新的窗口。 这样可以大幅度减少多余窗口的数量。\n详细信息可以参考 Luke Smith 的视频 。\n2. 需求分析 swallow 固然很好，但是有时候我们并不希望所有的窗口都 swallow 终端窗口， 比如有时候我在开发游戏过程中，我希望可以看到终端窗口的输出来进行 debug ，这时 swallow 补丁就无法满足我的需求了。\n我尝试过其他方式，比如使用 dynamicswallow patch ， 但是这个 patch 过于重量级，提供了太多不必要的功能。 所以我决定在 swallow patch 的基础上进行修改，实现只有特定窗口才会被 swallow 的功能。\n上面演示了noswallow的效果： 通过在执行命令前加上noswallow脚本， 比如noswallow ./your_app，就可以防止your_app被 swallow 。\n3. 实现原理 实现过程非常简单：\n因为我们需要进行进程间通信（终端和 dwm 之间）， 所以我们选择最简单的进程间通信方式：文件。\n在 dwm 的dwm.c中的swallow函数开始处，我们添加一个if语句：\nvoid swallow(Client *p, Client *c) { if (c-\u0026gt;noswallow || c-\u0026gt;isterminal) return; if (c-\u0026gt;noswallow \u0026amp;\u0026amp; !swallowfloating \u0026amp;\u0026amp; c-\u0026gt;isfloating) return; // add this to your code if (!access(\u0026#34;/tmp/noswallow\u0026#34;, F_OK)) return; access(\u0026quot;/tmp/noswallow\u0026quot;, F_OK)会检查/tmp/noswallow是否存在，如果存在则返回 0 ，否则返回-1 。\n这样我们就可以通过创建或删除/tmp/noswallow文件来控制是否 swallow 。\n注意需要sudo make clean install重新编译安装 dwm 。\n接下来编写一个简单的脚本noswallow：\n#!/bin/sh touch /tmp/noswallow \u0026#34;$@\u0026#34; # run your command with arguments rm /tmp/noswallow 这样在执行命令前加上noswallow脚本，就可以防止该窗口被 swallow 了！（记得将noswallow加到环境变量中。）\n具体可以参考我的 commit 。\n","permalink":"https://m1dsolo.github.io/posts/dwm-noswallow/","summary":"\u003ch2 id=\"1-前言\"\u003e1. 前言\u003c/h2\u003e\n\u003cp\u003edwm 是 X11 下的平铺式窗口管理器，它是用 C 语言编写的，非常轻量级，全部代码也才不到 2k 行。\n它提供了一些基本的窗口管理功能，对于额外的功能，可以通过修改源码来实现。\n目前 \u003ca href=\"https://dwm.suckless.org/patches/\"\u003esuckless 官网\u003c/a\u003e 上提供了非常多的补丁，可以用来扩展 dwm 的功能。\u003c/p\u003e\n\u003cp\u003e其中一个很重要的补丁就是 \u003ca href=\"https://dwm.suckless.org/patches/swallow/\"\u003eswallow\u003c/a\u003e ，\n它可以让 dwm 在启动一个新的应用程序时，将其嵌入到一个已有的窗口中，而不是启动一个新的窗口。\n这样可以大幅度减少多余窗口的数量。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"swallow\" loading=\"lazy\" src=\"https://m1dsolo.xyz/images/dwm-noswallow/swallow.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e详细信息可以参考 \u003ca href=\"https://www.youtube.com/watch?v=92uo5OBOKfY\u0026amp;t=327s\"\u003eLuke Smith 的视频\u003c/a\u003e 。\u003c/p\u003e\n\u003ch2 id=\"2-需求分析\"\u003e2. 需求分析\u003c/h2\u003e\n\u003cp\u003eswallow 固然很好，但是有时候我们并不希望所有的窗口都 swallow 终端窗口，\n比如有时候我在开发游戏过程中，我希望可以看到终端窗口的输出来进行 debug ，这时 swallow 补丁就无法满足我的需求了。\u003c/p\u003e\n\u003cp\u003e我尝试过其他方式，比如使用 \u003ca href=\"https://dwm.suckless.org/patches/dynamicswallow/\"\u003edynamicswallow patch\u003c/a\u003e ，\n但是这个 patch 过于重量级，提供了太多不必要的功能。\n所以我决定在 swallow patch 的基础上进行修改，实现只有特定窗口才会被 swallow 的功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"noswallow\" loading=\"lazy\" src=\"https://m1dsolo.xyz/images/dwm-noswallow/noswallow.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e上面演示了\u003ccode\u003enoswallow\u003c/code\u003e的效果：\n通过在执行命令前加上\u003ccode\u003enoswallow\u003c/code\u003e脚本，\n比如\u003ccode\u003enoswallow ./your_app\u003c/code\u003e，就可以防止\u003ccode\u003eyour_app\u003c/code\u003e被 swallow 。\u003c/p\u003e\n\u003ch2 id=\"3-实现原理\"\u003e3. 实现原理\u003c/h2\u003e\n\u003cp\u003e实现过程非常简单：\u003c/p\u003e\n\u003cp\u003e因为我们需要进行进程间通信（终端和 dwm 之间），\n所以我们选择最简单的进程间通信方式：文件。\u003c/p\u003e\n\u003cp\u003e在 dwm 的\u003ccode\u003edwm.c\u003c/code\u003e中的\u003ccode\u003eswallow\u003c/code\u003e函数开始处，我们添加一个\u003ccode\u003eif\u003c/code\u003e语句：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nf\"\u003eswallow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eClient\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eClient\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enoswallow\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eisterminal\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enoswallow\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eswallowfloating\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eisfloating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// add this to your code\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nf\"\u003eaccess\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;/tmp/noswallow\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eF_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003eaccess(\u0026quot;/tmp/noswallow\u0026quot;, F_OK)\u003c/code\u003e会检查\u003ccode\u003e/tmp/noswallow\u003c/code\u003e是否存在，如果存在则返回 0 ，否则返回-1 。\u003c/p\u003e","title":"在 dwm 中防止特定窗口被 swallow 的方法"},{"content":"1. 前言 Hugo 是一个用 Go 语言编写的静态网站生成器， 它可以将 Markdown 文件转换为 HTML 文件，支持主题和插件， 生成的网站可以直接部署到 GitHub Pages 、云服务器等。\n本文将介绍如何使用 Hugo 搭建个人博客并使用 GitHub Actions 自动部署到 GitHub Pages 上。\n实现的效果是，当我们将博客的 Markdown 文件推送到 GitHub 仓库时， GitHub Actions 会自动构建 Hugo 网站，并将生成的 HTML 文件推送到 GitHub Pages 上， 这样我们就可以通过https://\u0026lt;username\u0026gt;.github.io访问我们的博客。\n后面会大致介绍下如何将 Hugo 部署到云服务器上，没有特殊需求不建议折腾。\n2. 安装 Hugo 具体安装方法可以参考 Hugo 官方文档 。\n以我使用的 Arch Linux 为例，可以通过以下命令安装 Hugo ：\nsudo pacman -S hugo 3. 创建 Hugo 网站 初学者可以参考 Hugo 官方教程 。 由于我使用的是 PaperMod 主题， 如果你也想使用这个主题， 可以参考 PaperMod 安装教程 。\n以下我列出使用 git submodule 方法（推荐）创建 PaperMod 主题的 Hugo 网站的命令：\nhugo new site blog --format yaml # 可以替换 blog 为其他目录名 cd blog git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod echo \u0026#34;theme: [\\\u0026#34;PaperMod\\\u0026#34;]\u0026#34; \u0026gt;\u0026gt; hugo.yaml 如果你未来想要更新 PaperMod 主题，可以使用以下命令：\ngit submodule update --remote --merge 4. 编写博客 可以参考 如何新建文章 ， 以及 如何组织目录结构 。\n新建文章 hugo new content content/posts/hello-world/index.md content/posts/hello-world/index.md就是新建的文章的路径， 你可以在这个文件中使用 Markdown 语法编辑你的博客内容。\n其中draft字段决定了文章是否为草稿， 如果你想要发布这篇文章，可以将draft字段设置为false。\n预览 Hugo 网站 当你完成了博客的编辑，可以使用以下命令在本地运行 Hugo 网站：\nhugo server -D # -D 参数表示需要显示草稿 你可以在浏览器中访问http://localhost:1313（终端中输出的地址）从而在本地浏览你的博客。\n网站具有实时预览效果，每当你修改了博客内容后，浏览器会自动刷新。\n配置 Hugo 网站（可选） 具体网站的配置可以参考 Hugo 官方文档 以及 PaperMod 文档 。 也可以参考我个人博客网站的 配置 。\n5. 使用 Github 管理博客 使用版本控制工具可以方便我们管理博客的历史版本，同时也算是一种备份。\n创建 GitHub 仓库 具体如何创建可以搜网上的教程，这里不再赘述。 创建并提交后的仓库类似于 github.com/m1dsolo/blog 。\n6. 部署到 GitHub Pages 到目前为止，我们已经完成了本地 Hugo 网站的搭建和博客的编写， 接下来我们将介绍如何使用 GitHub Actions 自动部署到 GitHub Pages 上。\nGitHub Actions 配置 首先对于我们刚刚创建好的 GitHub 仓库，我们需要配置 GitHub Actions ， 这样每当我们将博客的 Markdown 文件推送到 GitHub 仓库时， GitHub Actions 会自动构建 Hugo 网站，并将生成的 HTML 文件推送到 GitHub Pages 上。\n在博客仓库的根目录下创建.github/workflows目录， 然后在该目录下创建deploy.yml文件，填入：\nname: Deploy with Hugo on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy Github uses: peaceiris/actions-gh-pages@v4 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: m1dsolo/m1dsolo.github.io publish_branch: main publish_dir: ./public 创建 Personal Token 因为 GitHub Actions 需要推送生成的 HTML 文件到 GitHub Pages 上， 也就是需要访问另外一个仓库，通过配置 Personal Token 可以赋予当前仓库操控另外一个仓库的权限。 可以参考 peaceiris/actions-gh-pages 。\n如果之前没有创建过 Personal Token ，可以在 github tokens 页面创建一个 token ，\n配置 Secrets 在 GitHub 博客仓库的 Settings -\u0026gt; Secrets 页面中，添加一个名为PERSONAL_TOKEN的 secret ， 值为你刚刚创建的 Personal Token 。（PERSONAL_TOKEN这个变量名与deploy.yml中变量名保持一致）。\n创建 GitHub Pages 仓库 创建 GitHub 仓库\u0026lt;username\u0026gt;.github.io，其中\u0026lt;username\u0026gt;为你的 GitHub 用户名。 这个仓库将用于存放 Hugo 的生成的 html 文件， github 会自动将这些文件部署到https://\u0026lt;username\u0026gt;.github.io。 以我的 GitHub 为例，我的仓库为 m1dsolo.github.io 。\n7. 配置图床（可选） 博客中的图片可以使用图床来存储，这样可以减少 Git 仓库的大小。 可以选择一些免费图床，但是有些图床可能会有流量限制，同时可能会有访问速度的问题。 我这里选择使用自己的云服务器作为图床。\n大致步骤：\nupload_image脚本传输图片到云服务器 nginx配置图片访问路径 neovim插件来自动上传图片 具体就不细说了，以后有机会再展开。\n8. 配置搜索（可选） 参考 PaperMod 搜索文档 。\n9. 配置 favicon （可选） favicon 是网站的图标，比如：\n你可以使用 favicon.io 来生成 favicon 。\n只需要将生成的favicon.ico放到static目录下，然后修改hugo.yaml：`\nparams: assets: favicon: \u0026#34;favicon.ico\u0026#34; favicon16x16: \u0026#34;favicon.ico\u0026#34; favicon32x32: \u0026#34;favicon.ico\u0026#34; apple_touch_icon: \u0026#34;favicon.ico\u0026#34; safari_pinned_tab: \u0026#34;favicon.ico\u0026#34; 9. 配置评论（可选） 这里我选用 giscus 来配置评论功能。 因为它开源同时支持 GitHub 登录，不需要注册额外的账号。\n配置 giscus 链接为 giscus.app 。 具体配置步骤如下：\n在你的仓库\u0026lt;username\u0026gt;.github.io中启用 Discussion （Settings -\u0026gt; Features -\u0026gt; Discussions）， 同时确保你的仓库是公开的。\n安装 giscus app ，赋予仓库\u0026lt;username\u0026gt;.github.io权限。\n根据 giscus 的script修改hugo.yaml：\ngiscus 的 script 如下： 修改为对应的yaml格式写入hugo.yaml中：\nparams: giscus: repo: \u0026#34;m1dsolo/m1dsolo.github.io\u0026#34; repoId: \u0026#34;R_kgDONmlNVQ\u0026#34; category: \u0026#34;Announcements\u0026#34; categoryId: \u0026#34;DIC_kwDONmlNVc4Cm94p\u0026#34; mapping: \u0026#34;pathname\u0026#34; strict: 0 reactionsEnabled: 1 emitMetadata: 0 inputPosition: \u0026#34;bottom\u0026#34; theme: \u0026#34;preferred_color_scheme\u0026#34; lang: \u0026#34;zh-CN\u0026#34; crossorigin: \u0026#34;anonymous\u0026#34; 在layouts/partials下新建comments.html文件并填入：\n\u0026lt;div id=\u0026#34;tw-comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 默认是暗色，根目录下的配置中的主题默认也是暗色 const getStoredTheme = () =\u0026gt; localStorage.getItem(\u0026#34;pref-theme\u0026#34;) === \u0026#34;light\u0026#34; ? \u0026#34;{{ .Site.Params.giscus.lightTheme }}\u0026#34; : \u0026#34;{{ .Site.Params.giscus.darkTheme }}\u0026#34;; const setGiscusTheme = () =\u0026gt; { const sendMessage = (message) =\u0026gt; { const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); if (iframe) { iframe.contentWindow.postMessage({giscus: message}, \u0026#39;https://giscus.app\u0026#39;); } } sendMessage({setConfig: {theme: getStoredTheme()}}) } document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { const giscusAttributes = { \u0026#34;src\u0026#34;: \u0026#34;https://giscus.app/client.js\u0026#34;, \u0026#34;data-repo\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34;, \u0026#34;data-repo-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34;, \u0026#34;data-category\u0026#34;: \u0026#34;{{ .Site.Params.giscus.category }}\u0026#34;, \u0026#34;data-category-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34;, \u0026#34;data-mapping\u0026#34;: \u0026#34;{{ .Site.Params.giscus.mapping }}\u0026#34;, \u0026#34;data-strict\u0026#34;: \u0026#34;{{ .Site.Params.giscus.strict }}\u0026#34;, \u0026#34;data-reactions-enabled\u0026#34;: \u0026#34;{{ .Site.Params.giscus.reactionsEnabled }}\u0026#34;, \u0026#34;data-emit-metadata\u0026#34;: \u0026#34;{{ .Site.Params.giscus.emitMetadata }}\u0026#34;, \u0026#34;data-input-position\u0026#34;: \u0026#34;{{ .Site.Params.giscus.inputPosition }}\u0026#34;, \u0026#34;data-theme\u0026#34;: getStoredTheme(), \u0026#34;data-lang\u0026#34;: \u0026#34;{{ .Site.Params.giscus.lang }}\u0026#34;, \u0026#34;data-loading\u0026#34;: \u0026#34;lazy\u0026#34;, \u0026#34;crossorigin\u0026#34;: \u0026#34;anonymous\u0026#34;, }; // 动态创建 giscus script const giscusScript = document.createElement(\u0026#34;script\u0026#34;); Object.entries(giscusAttributes).forEach( ([key, value]) =\u0026gt; giscusScript.setAttribute(key, value)); document.querySelector(\u0026#34;#tw-comment\u0026#34;).appendChild(giscusScript); // 页面主题变更后，变更 giscus 主题 const themeSwitcher = document.querySelector(\u0026#34;#theme-toggle\u0026#34;); if (themeSwitcher) { themeSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); } const themeFloatSwitcher = document.querySelector(\u0026#34;#theme-toggle-float\u0026#34;); if (themeFloatSwitcher) { themeFloatSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); } }); \u0026lt;/script\u0026gt; 10. 配置数学公式（可选） 这里使用mathjax来配置数学公式。\n参考 官方文档 。\n在layouts/partials下新建mathjax.html文件并填入： \u0026lt;script id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; MathJax = { tex: { displayMath: [[\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;], [\u0026#39;$$\u0026#39;, \u0026#39;$$\u0026#39;]], // block inlineMath: [[\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]] // inline }, loader:{ load: [\u0026#39;ui/safe\u0026#39;] }, }; \u0026lt;/script\u0026gt; 在layouts/partials下新建extend_head.html文件并填入： {{ if or .Params.math .Site.Params.math }} {{ partialCached \u0026#34;math.html\u0026#34; . }} {{ end }} 在hugo.yaml`中添加以下配置： markup: goldmark: extensions: passthrough: delimiters: block: - - \\[ - \\] - - $$ - $$ inline: - - \\( - \\) enable: true params: math: true 测试用数学公式：\n行内数学公式：\\(a^2 + b^2 = c^2\\)。 块公式： $$ a^2 + b^2 = c^2 $$ \\[ a^*=x-b^* \\] latex: \\[ \\begin{aligned} KL(\\hat{y} || y) \u0026amp;= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026amp;= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} \\] 行内数学公式：\\(a^2 + b^2 = c^2\\)。\n块公式：\n$$ a^2 + b^2 = c^2 $$\\[ a^*=x-b^* \\]latex:\n\\[ \\begin{aligned} KL(\\hat{y} || y) \u0026= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} \\]mathjax渲染的数学公式结果如下（图片）：\n我遇到的问题主要是在某些网络环境下mathjax无法读取： 以后有需要再研究如何解决。\n11. Google Analytics （可选） Google Analytics 可以帮助我们分析网站的访问情况，可以参考 官方文档 。\n首先在 google analytics 中注册一个账号，然后获取tracking_id。\n将tracking_id添加到hugo.yaml中：\nservices: googleAnalytics: id: \u0026#34;G-XXXXXXXXXX\u0026#34; # replace with your tracking_id 在layouts/partials/extend_head.html中添加： {{ template \u0026#34;_internal/google_analytics.html\u0026#34; . }} 12. 访问量统计（可选） 我希望可以统计各个博客以及整个网站的访问量， 这里使用 busuanzi 来进行统计。 具体安装使用教程见 github 。\n13. Markdown 通知块（可选） Hugo 默认不支持 Markdown 的通知块， 我们可以使用 hugo-notice 来实现这一功能。\n安装 hugo-notice ：git submodule add --depth=1 https://github.com/martignoni/hugo-notice.git themes/hugo-notice。\n然后在hugo.yaml中修改theme为：\ntheme: [hugo-notice, \u0026lt;your theme name\u0026gt;] 使用方法见： hugo-notice 。\n效果： 注释\n我是注释！\n警告\n我是警告！\n提示\n我是提示！\n信息\n我是信息！\n14. 部署至云服务器（进阶） 由于国内访问 GitHub Pages 速度可能较慢，可以选择将个人博客网站部署到国内云服务器上。 我选择同时在云服务器上也部署博客网站主要是因为有一台云服务器闲置，不折腾下感觉浪费了。\n部署到云服务器上大致以下步骤：\n购买云服务器 购买域名 配置域名解析 配置 Nginx 域名备案 将备案信息添加到 footer secrets 配置云服务器的私钥 修改deploy.yml 大部分内容可以网上搜到，我具体展开介绍下将备案信息添加到 footer和修改 deploy.yml。\n将备案信息添加到 footer 在layouts/partials/extend_footer.html内新增：\n\u0026lt;div style=\u0026#34;display: flex; align-items: center; justify-content: center;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/image/beian-logo.png\u0026#34; width=\u0026#34;12\u0026#34; style=\u0026#34;margin-right: 5px;\u0026#34;/\u0026gt; \u0026lt;a href=\u0026#34;https://beian.miit.gov.cn\u0026#34; rel=\u0026#34;noreferrer\u0026#34; target=\u0026#34;_blank\u0026#34; style=\u0026#34;font-size: 12px;\u0026#34;\u0026gt;京 ICP 备 2025109231 号-1\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 具体备案信息修改为自己的即可。\n修改deploy.yml 注意需要在hugo --minify时使用-b 参数来指代不同的baseURL， 因为 GitHub Pages 的域名是https://\u0026lt;username\u0026gt;.github.io， 与个人网站的域名不同。\nname: Deploy with Hugo on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: submodules: true fetch-depth: 1 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build for Github run: hugo --minify -b https://m1dsolo.github.io/ - name: Deploy Github uses: peaceiris/actions-gh-pages@v4 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: m1dsolo/m1dsolo.github.io publish_branch: main publish_dir: ./public - name: Build for Server run: hugo --minify -b http://m1dsolo.xyz/ - name: Deploy Server uses: wlixcc/SFTP-Deploy-Action@v1.2.5 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: username: root server: ${{ secrets.SERVER_IP }} ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }} local_path: ./public/* remote_path: /var/www/blog sftpArgs: \u0026#39;-o ConnectTimeout=5\u0026#39; 注意将上面的-b参数改为你自己的域名。\n15. 结语 通过本文的步骤，我们成功地使用 Hugo 搭建了个人博客网站，并通过 GitHub Actions 实现了自动部署到 GitHub Pages 的功能。\n现在，每次你完成博客的撰写，只需将仓库推送到 GitHub ， 更新的内容就会自动部署到你的个人博客网站 https://\u0026lt;username\u0026gt;.github.io 上。 （别忘了将博客内的 draft 字段改为 false）\n","permalink":"https://m1dsolo.github.io/posts/hugo-blog/","summary":"\u003ch2 id=\"1-前言\"\u003e1. 前言\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/gohugoio/hugo\"\u003eHugo\u003c/a\u003e 是一个用 Go 语言编写的静态网站生成器，\n它可以将 Markdown 文件转换为 HTML 文件，支持主题和插件，\n生成的网站可以直接部署到 GitHub Pages 、云服务器等。\u003c/p\u003e\n\u003cp\u003e本文将介绍如何使用 Hugo 搭建个人博客并使用 GitHub Actions 自动部署到 GitHub Pages 上。\u003c/p\u003e\n\u003cp\u003e实现的效果是，当我们将博客的 Markdown 文件推送到 GitHub 仓库时，\nGitHub Actions 会自动构建 Hugo 网站，并将生成的 HTML 文件推送到 GitHub Pages 上，\n这样我们就可以通过\u003ccode\u003ehttps://\u0026lt;username\u0026gt;.github.io\u003c/code\u003e访问我们的博客。\u003c/p\u003e\n\u003cp\u003e后面会大致介绍下如何将 Hugo 部署到云服务器上，没有特殊需求不建议折腾。\u003c/p\u003e\n\u003ch2 id=\"2-安装-hugo\"\u003e2. 安装 Hugo\u003c/h2\u003e\n\u003cp\u003e具体安装方法可以参考 \u003ca href=\"https://gohugo.io/getting-started/installing\"\u003eHugo 官方文档\u003c/a\u003e 。\u003c/p\u003e\n\u003cp\u003e以我使用的 Arch Linux 为例，可以通过以下命令安装 Hugo ：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo pacman -S hugo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"3-创建-hugo-网站\"\u003e3. 创建 Hugo 网站\u003c/h2\u003e\n\u003cp\u003e初学者可以参考 \u003ca href=\"https://gohugo.io/getting-started/quick-start\"\u003eHugo 官方教程\u003c/a\u003e 。\n由于我使用的是 \u003ca href=\"https://github.com/adityatelange/hugo-PaperMod\"\u003ePaperMod\u003c/a\u003e 主题，\n如果你也想使用这个主题，\n可以参考 \u003ca href=\"https://github.com/adityatelange/hugo-PaperMod/wiki/Installation\"\u003ePaperMod 安装教程\u003c/a\u003e 。\u003c/p\u003e\n\u003cp\u003e以下我列出使用 git submodule 方法（推荐）创建 PaperMod 主题的 Hugo 网站的命令：\u003c/p\u003e","title":"使用 Hugo 搭建个人博客网站并自动部署至 GitHub Pages "}]